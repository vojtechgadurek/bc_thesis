\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\section{Comparison of HPW to IBLT}
We have found that HPW did not have a worse recovery in experiments than IBLT. However, it consumes much less memory, making it much more performant in the encoding phase. We have not measured the decoding phase rigorously, but from some experiments, we predict that IBLT is a little bit faster than HPW. As such, finding symmetric differences between sets with larger symmetric differences when using IBLT may provide an advantage. We implemented only the original version of IBLT. However, more memory-efficient variations were described. 

\section*{Improvements}
We increased the recovery ratio from $1$:$0.8$ to $1$:$1.52$ for the recovery of $k$-mer sets. When we ran some further experiments, we found that when Oracle provides fewer possibilities (i.e. predictions with greater correct), then the recovery ratio may be improved.

It may be futile to explore possibilities and ways to improve oracle prediction. One idea is to encode more information into the sketch. An easy way to improve bounds would be to use non-uniform hashing. Our framework is prepared for such.

Another avenue for further research could be to find rigorous bounds on such decoding. However, we fear such an endeavor may not be easy.

Another question is whether there are other domains for which recovery with Oracle would be beneficial.

There is also a known approach to increase the ratio to $1$:$0.92$ by using non-uniform hash functions as Michael Rink's experimental result shows \cite{DBLP:journals/corr/abs-1204-2131}. We could incoporate such solutution to our, however this would be at cost to performance as it requires to use up to $21$ hash functions.


\section*{Implementation}
We achieved a fast but highly generic codebase, allowing users to easily swap even low-level components with no or little cost to overall performance. 

In the chapters dedicated to each library, we further discussed possible work on it. To sum up, there is still work to do on SymmetricDifferenceFinder. 

Some technical debt needs to be resolved, largely in the more experimental parts of the project, such as recovery with oracles.

During the project, we met and fought successfully with the language's limitations. The main issue is the lack of support for recompiling functions for some known parameters. For example, have a generic $Divide(a,b) = a / b$; if we would want many operations for the same $b:=7$, we would maybe want to recompile such function by calling $Divide(a) = Recompile(Divide, b = 7)$ during runtime we could. We circumvented that by using Expression Trees; however, this is far from a pleasant experience. 

