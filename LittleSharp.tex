\chapter{LittleSharp}\label{LittleSharp}
\section{Motivation}
We used expression trees extensively in the project, but they have a few issues. The first and foremost is that the native Expression Tree library is not statically checked. This leads to many hard-to-debug errors. Also, code written in Expression Trees is hard to read, making debugging such code much more complex. As such, we decided to create a wrapper around Expression Trees that would provide some static checking but not at the cost of versatility. We created a standalone library called LittleSharp. Even though its main purpose was to serve the needs of our project, we think it may be useful for others. However, it is mainly limited to operations with numeric types. The library is at GitHub: \url{https://github.com/vojtechgadurek/LittleSharp}.

\section{How to use}
In this section, we introduce the library briefly. First, we will write a short function that declares $c$ with value $5$, adds $a$,$b$, and $c$, and returns the sum.
\begin{lstlisting}
// Declare a function with two parameters, a and b
var f = CompiledFunctions
    //Create<TIn1, ... , TInn, TOut>(out var input1_, ...)
    //creates a function with arguments with types TIn1 to Tinn
    //and return type TOut
    //when one wants to create action,
    //they should use CompiledActions class
    .Create<int, int, int>(out var a_, out var b_);
// a and b have types Variable<int>
// f.S is a scope that is going to be executed when f is called
// S is an abbreviation for Scope
// c = 5; 
f.S.DeclareVariable<int>(out var c_, 5)
// c have also type Variable<int>
// return a + b + c
	.Assign(f.Output, a.V + b.V + c.V);
// f.Output is the value that is going to be returned
// .Assign(a, b) is the same as a = b;
// a.V is equal to SmartExpression<T>, V is abbreviation for Value
Expression<Func<int, int, int>> addExpression = f.Construct();
Func<int, int, int> add = addExpression.Compile();
//By calling Compile, the expression tree is then compiled 
\end{lstlisting}

We may also use flow control statements, like while and if. Imagine having a buffer $B$ and some number $N$ to determine the number of values in the buffer.  We would like to sum all values together, which can be done as folows:
\begin{lstlisting}
// Declare a function with two parameters, a and b
var f = CompiledFunction
    .Create<int[], int, int>(out var B_, out var N_);
f.S.DeclareVariable(out var i_, 0)
    //We declared variable i with value 0 of type int
    //It is possible to declare variable without explicit
    //initialization, however this is not recomended as
    //it may lead to unexpected behaviour
    .While(
        i_.V < N.V, 
        new Scope()
            .DeclareVariable(
                out var value,
                // By calling ToTable<int>(), we hint compiler
                // that the underlying type is a table,
                // thus we may use [] syntax to access fields
                // B_.V.ToTable<int>() is going to have 
                // type ArrayAccess<int, int[]> 
                B_.V.ToTable<int>()[i_.V]
                )
            .Assign(f.Output, f.Output.V + value.V)
            .Assign(i_, i_.V + 1)

Func<int[], int, int> F = f.Construct().Compile()
\end{lstlisting}
This code is equivalent to following:
\begin{lstlisting}
// Declare a function with two parameters a and b

var F = (int[] B, int N) => {
    int i = 0;
    int output = 0;
    while(i < N){
        int value = B[i];
        output += value;
    }
    return output;
}
\end{lstlisting}
\subsection{Naming Conventions}
As we introduced some new concepts, we also introduced naming conventions for them. Variables should end with underscore \_; when the variable is converted to some special type, it should end with \_NAME or its abbreviation. For example:
\begin{lstlisting}
var a = CompiledAction.Create<int[]>(out var table_)
a.S.Macro(var out table_T, table_.V.ToTable<int>());
\end{lstlisting}

\subsection{Debugging}
Debuging expression trees is hard. There are Visual Studio extensions for that. Two libraries can be used to visualize them: Readable Expressions and Expression Tree Visualizer. \cite{ExpressDebug} So, one see the acctually generated code. 
Sadly, Readable Expression does not work with LittleSharp. One can also use some tools provided by the library itself. For example, it is possible to use Print(), to log some data. For example:
\begin{lstlisting}

// Logger has to implement method WriteLine(string line)
class Logger{
    public List<string> Data = new ();
    void WriteLine{string line}{
        Data.Add(line);
    }
}

var logger = new Logger();

//This is going to change a logger for all instances of Scopes
// As such it should be used only for debugging
// When DebugOutput is not set, 
//than it prints to standard output
Scope.SetDebugOutput(logger);

var a = CompiledAction.Create()
a.S.Print("Start")
    .Declare(out var v_, 0)
    .Print(v_.ToStringExpression())
    //It is important not call ToString() as 
    //then we would call ToString on v_, what is Variable<int>
    // not the underlying type

a.Construct().Compile()()
// Logger.Data contains "Start" and "0"
\end{lstlisting}


\section{Implemenation details}
\subsection{Architecture}
There are three main types: Variables, SmartExpression, Scopes
\subsubsection{Variables}
Variable wraps two possible expressions: ParameterExpression and Variable Expression. This means a Variable should be seen as an expression that holds a value, and a value might be assigned to it. There is a generic version of Variable, and this is Variable<T>. This should be preferred to use as it contains information about the type of variable that is held by Variable<T>.



\subsubsection{SmartExpression}
SmartExpression wraps all expressions. As Expressions are the main building block of Expression Trees, SmartExpression is going to fit this function also as amin building block. SmartExpression also has its generic version, SmartExpression<T>. This generic version also holds an expression of type T. 


\subsubsection{Scope}
Scopes are the most interesting and complex of the types provided. They hold together SmartExpressions and Variables. One should imagine as a normal scope in C\#, would look like. They should make it easier not to use variables from different scopes. A generic version, Scope<T>, also has a return type of T. 


\subsection{SmartExpression operators}
As our goal is to provide safe arithmetic operations, we simplified SmartExpression to hold some binary numeric type. As such, we overloaded nearly all binary operators to work on the same types. We show an implementation of an overload for addition.

\begin{lstlisting}
public class SmartExpression<TValue>{
    public readonly Expression Expression;
    //More stuff
    public static SmartExpression<TValue> operator+
    (
        SmartExpression<TValue> a, 
        SmartExpression<TValue> b
    )
    {
        //Expression.Add( ome_expression, another_expression) 
        //is from expression trees API
        return  new SmartExpression<TValue>(
            Expression.Add(a.Expression, b.Expression)
            );
    }
    //More stuff
}
//This allows us to do this
SmartExpression<int> a = 1;
SmartExpression<int> b = 2;
SmartExpression<int> result = a + b;
//In the language of expression trees,
//this can be translated to the folowing
var a = Expression.Constant(1);
var b = Expression.Constant(2);
var result = Expression.Add(a, b);
\end{lstlisting}
It may not be clear why the latter approach is so bad that developing a new library is well motivated. The problem becomes visible with more complex code. The more expressions in the code, the more problems. The problems are mainly with variables, as one needs to make sure they all have the right types and are all initiated. Our library solves many of these problems. Typing gives more safety and partially solves problems with assigning values of bad types and then having to deal with runtime errors. For example:
\begin{lstlisting}
var S = new Scope();
S.DeclareVariable(a_, 0);
S.DeclareVariable(b_, 1);
S.DeclareVariable(c_, "a");
S.DeclareVariable(d_, 0l); 
// d_ has SmartExpression<long> type

a_ + b_; //Compile error
a_.V + b_.V; // Compiles
a_.V + c_.V; // Compile error as + is overloaded only for 
//SmartExpresion<T>s with the same T
a_.V + d.V; // Compile error for the same reason
a_.V.Convert<long>() + d.V; // Compiles
//This could be translated to (long) a + d 

a_.V.ForceType<long>() + d.V;
// Compiles, fails during runtime
// ForceType cast only SmartExpression<T> to different type,
// but not the underlying expression
a_.Assign(S, b_.V); //Compiles
a_.Assign(S, d_.V); //Does not compile as to Variable<T> 
// may be only assigned value with type T
\end{lstlisting}
This behavior provides enough safety to catch most errors, especially bad assignments.

\subsection{Scopes}
Scopes are more interesting. They hold both variables and expressions to be executed. We may imagine that they hold a list of expressions and a list of variables. Expressions are executed in the order in which they were added to the scope. They are not executed when we do not add an expression to the scope. All variables are declared before all expressions. When declaring a variable with some assigned value, one should not forget that this assigned value is, in reality, an expression. This means we are doing two things: declaring a variable and assigning a value. Example: 
\begin{lstlisting}
var S = new Scope();
S
    .DeclareVariable(a_, 0)
    .Macro(out var x_, a_ + 10)
    .DeclareVariable(b_)
    .Function( (x) => x + 1, x_, out var z_)
    //The function is never executed
    //as z_ is then never used.
    .Function( (x) => x + 13, x_, out var y_)
    .Assign(b_, y_)

//First we declared variables a_ and b_
//Then a_ = 0
//Then b_ = 13
\end{lstlisting}

Scopes may be contained in other scopes and may also contain them. Variables may be used only from the scope they are declared in or any scope contained in that scope. The property being contained is transitive. This behavior is the same as expected from normal scopes in C\#.

Scopes may or may not have a return value. 


\section{Future work}
This library is mostly experimental and serves more as a glimpse into a concept than a fully functional library. This makes sense as it was a side project created out of a need for better API for Expression Trees. 

There is some technical debt in architecture. The main problem is that when a Scope cannot be added as a Scope to another Scope, it needs to be made a SmartExpression first, which is problematic as it makes analyzing such code much harder. The solution to this problem is decupling compilation from expression trees via visitor pattern.

LittleSharp would benefit enormously from using Roslyn more extensively, especially source generators and analyzers, to build a less error-prone experience. Analyzers could be used to write custom compile errors, thus helping users debug code written using SmartExpression better. Code Generators could be used to create a more advanced type system supporting custom types.


