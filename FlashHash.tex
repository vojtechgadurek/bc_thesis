\chapter{FlashHash}\label{FlashHash}
\section{Motivation}
The project required access to families of fast hash functions. Sadly, no libraries were offering such. The base C\# library provides only cryptographic hashing functions. Other libraries offered hashing only from byte arrays. This meant we had to convert integer values to byte arrays, which caused performance bottlenecks. This led to the decision to implement, such a library ourselves. The library is at GitHub:  \url{https://github.com/vojtechgadurek/FlashHash}.

\section{How to Use}
FlashHash implements multiple hash function families - Linear Congruence, Polynomial, Tabulation, and Multiply Shift.
There are two important concepts to understand: (Hash Function) Schemes and (Hash Function) Families. 
\subsubsection{Schemes}
Schemes describe one hash function. One may build a hash function out of it:
\begin{lstlisting}
var scheme = new LinearCongruenceScheme(10, 5, 7)
// This scheme yields the following hash function:
//  (10*x + 5) % Prime % 7
// Prime represents the closest Mersene prime 
	//greater than the size (7)

Expression<Func<ulong, ulong>> expression = scheme.Create()
// Building an expression tree is not computationally expensive

Func<ulong, ulong> hashFunction = expression.Compile();
// However, the compilation is resource-intensive
\end{lstlisting}

\subsubsection{Families}
Families are merely factories of schemes:
\begin{lstlisting}
var family = new LinearCongruenceFamily();
family.SetRandomness(new Random(42));
// Custom randomness can be set
ulong size = 10;
Func<ulong, ulong> hashFunction = 
    family.GetScheme(size).Create().Compile()
// Retrieves a random hashing function 
//from the linear congruence family
\end{lstlisting}



\section{Implementation}
\subsection{Simplest Solution}
There is a very simple solution:
\begin{lstlisting}
var CreateLinearCongruenceHashingFunction = 
    (long size) =>
    {
        ulong a = Random.GetRandomUInt64();
        ulong b = Random.GetRandomUInt64();
        ulong p = Random.GetGoodPrime(size);
        return (ulong x) => (a * x + b) % size % prime;
    }
\end{lstlisting}
This approach has one very large advantage: it is simple. On the other hand, we pay for this simplicity by performance, as constant optimization and inlining are not possible. One can easily see that linear congruence uses modulo operators. These are quite expensive, and even more so if they are not constant optimized. This implementation is circa $2-4$ times slower, depending on the processor, than when \texttt{a}, \texttt{b}, \texttt{ size}, and \texttt{prime} were known in advance.

There are two possible solutions to this in C\#: Expression Trees and Runtime Types with Struct Delegates. We talked about these in \ref{FlashHash} chapter. We chose a solution via expression trees, but to interested readers, we first describe the solution by Runtime Types with Struct Delegates. 

\subsection{Possible solution via Runtime Types with Struct Delegates}
First, we have this implementation:
\begin{lstlisting}
//For sharplab
using SharpLab.Runtime; 

interface IConstant{
    ulong Get();
}

//Constants are going to look something like this
struct One : IConstant
{
    public ulong Get() => 1L; 
}

struct Six : IConstant
{
    public ulong Get() => 6; 
}

struct Prime : IConstant
{
    public ulong Get() => 11; 
}
//This is just for sharplab
[JitGeneric(typeof(One), typeof(Six), typeof(Prime),typeof(Six)) ]
struct HashingFunction<TA, TB, TSIZE, TPRIME> 
where TA : struct, IConstant
where TB : struct, IConstant
where TSIZE :  struct, IConstant
where TPRIME : struct, IConstant
{
    public HashingFunction(){}
    
    readonly TA a = default(TA);
    readonly TB b = default(TB);
    readonly TSIZE size = default(TSIZE);
    readonly TPRIME prime = default(TPRIME);
    public ulong Invoke(ulong value) 
        => 
    (a.Get() * value + b.Get())% prime.Get() %size.Get();
} 

// Then hf.Invoke = (x) => (1*x + 6) %  11 % 6;
// But compiler knows this during compilation
\end{lstlisting}
This works. If we look at the generated IL code, we see that all values got inlined:

There is one small problem: We need access to families of hashing functions, but we cannot implement a constant type for every number. The solution to this is IL code and runtime types. It is possible in C\# to create types during runtime, and then we may use reflection to build hashing functions out of the created constant. Implementation of the Linear Congruence family would thus look like this:

\begin{lstlisting}
static class ConstantFactory(){
    Type GetConstant(ulong value){
    //Magic
    }
}

class LinearCongruenceFamily {
    IHashingFunction GetHashingFunction(size){
        //Prepare
        ulong a = Random.GetRandomUInt64();
        ulong b = Random.GetRandomUInt64();
        ulong prime = GetGoodPrime(size);
        Type A = ConstantFactory.Get(a);
        Type B = ConstantFactory.Get(b);
        Type PRIME = ConstantFactory.Get(prime);
        Type SIZE = ConstantFactory.Get(SIZE);
        //Reflection
        var maker = typeof(LinearCongruence<>).MakeGenericType(
            new {A,B, PRIME, SIZE}
        );
        return (IHashingFunction) Activator.CreateInstance(maker);
    }
}
\end{lstlisting}


\subsubsection{Constant Factory}
The implementation of such a library function may look something like this:
\begin{lstlisting}
public static Type CreateRuntimeConstant(long value)
{
    //Assembly to which we add the type
    AssemblyName assemblyName = new AssemblyName("DynamicAssembly");
    AssemblyBuilder assemblyBuilder =
        AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
    ModuleBuilder moduleBuilder =
        assemblyBuilder.DefineDynamicModule("DynamicModule");

    //Type builder with struct semantics
    TypeBuilder tb = 
        moduleBuilder.DefineType(
            $"long_{value}",
            TypeAttributes.Public | TypeAttributes.Sealed | 
            TypeAttributes.SequentialLayout 
            | TypeAttributes.BeforeFieldInit,
            typeof(ValueType),
            new Type[] { typeof(IConstant) }
        );
    
    var method = tb.DefineMethod("GetValue", 
    MethodAttributes.Public | 
    MethodAttributes.Virtual | 
    MethodAttributes.HideBySig, typeof(long), Type.EmptyTypes);
    var il = method.GetILGenerator();
    il.Emit(OpCodes.Ldc_I8, value);
    il.Emit(OpCodes.Ret);
    tb.DefineMethodOverride(
        method,
        typeof(IConstant).GetMethod("GetValue")
        );
    return tb.CreateType();
} 
\end{lstlisting}
This solution has a small problem. It does not work, and we do not know why. We suppose Roslyn treats Runtime-generated types differently, but we have not investigated further.


\subsection{Solution using Expression Trees (LittleSharp)}
We are going to use LittleSharp for work with expression trees. Reasons for developing this library are given in the chapter about LittleSharp \ref{LittleSharp}.

Using LittleSharp the simplest solution looks like this:
\begin{lstlisting}
var CreateLinearCongruenceHashingFunction = 
    (long size) =>
    {
        ulong a = Random.GetRandomUInt64();
        ulong b = Random.GetRandomUInt64();
        ulong p = Random.GetGoodPrime(size);
        var f = CompiledFunctions.Create<ulong, ulong>
        (out var input_, out var hash_);
        f.S.Assign(f.Output, (a * input_ + b) % size % prime);
        return f.Construct().Compile();
    }
    //Returns Func<ulong, ulong>
    //This code is constant optimized
\end{lstlisting}

\subsection{Comparing Aproaches}
Both approaches add significant complexity to the project. The main issue is that switching the context between runtime-generated and normal code is not smooth. One needs to use reflection calls in case of IL-generated code or delegates calls for Expression Trees. 
Also, using runtime-generated code will cause type safety issues. This is because types cannot be checked before the code is generated during runtime. This may cause many hard-to-find bugs that may cause runtime errors.

Both approaches are comparable. They lead to constant optimized code and allow inlining with additional work. Expression Trees are easier to work with because their API is simpler and requires much less reflection code. Some type of safety can also be added; this is discussed in the chapter \ref{LittleSharp}. Finally, expression trees are probably used more by the community, which means there are more sources to learn about them.

Secondly, and most importantly, we are unsure whether we could make the approach with struct delegates work. We could possibly do some hacks, maybe using a source generation or modifying Roslyn itself. Considering this, we have chosen the approach using Expression Trees. 

\section{Future work}
We see the library as very complete, but it could provide more hash function families. It could also possibly provide a possibility to hash from any integer type to any integer type. This would be very simple to implement.
Some sort of caching for the compiled expression tree hashing function could be useful.

It would probably be interesting to investigate why exactly struct delegates approach does not work. It is possible, that some optimization is not turned off for runtime types; however, we are not sure. This was pointed to us by Mgr. Radek Zikmund.

